// Do a dfs on the original graph, keeping track of the finish times of each node

stack STACK

void DFS(int source) {
    visited[s]=true
    for all neighbours X of source that are not visited:
        DFS(X)
    STACK.push(source)
}


//Reverse the original graph



// Do  on the reversed graph, with the source vertex as the vertex on top of the stack. When  finishes, all nodes visited will form one Strongly Connected Component

while STACK is not empty:
    source = STACK.top()
    STACK.pop()
    if source is visited :
        continue
    else :
        DFS(source)





